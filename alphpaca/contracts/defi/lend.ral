Contract Lend (
    owner: Address,                 // Developer Address
    ntoken: ByteVec,                // Native Token
    mut tfees: U256,                // Native Token Fees
    mut fees: U256,                 // Regular Fees 2% and 0.05 Fee For Listings Discounts with PACA
    mut contracts: U256,            // Contracts Made
    mut funds: U256,                // ALPH in contract
    mut nfunds: U256,               // PACA in contract
    // Pool Loan
    pool: ByteVec,
    loan: ByteVec
) {
    // Events
    event Removed(reciever: Address, amount: U256)
    event LoanCreated(creator: Address, loanid: ByteVec, token: ByteVec, amount: U256, wtoken: ByteVec, wamount: U256, funds: U256, nfunds: U256)

    // Error Codes
    enum Error {
        InvalidCaller = 1
    }

    pub fn getNToken() -> ByteVec {
        return ntoken
    }

    pub fn getNTokenFee() -> ByteVec {
        return tfees
    }

    pub fn getFee() -> ByteVec {
        return fees
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn loan(want: ByteVec, wamount: U256, collateral: ByteVec, amount: U256, interest: U256, time: U256) -> (ByteVec) { // ALPH Fees (User to User)
        // Create Sub Contract
        let loanee = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Loan.encodeFields!(want, wamount, collateral, amount, interest, time, loanee, time, interest, amount, loanee)

        let newloan = createContract!{loanee -> ALPH: 1 alph}(
            loan,
            encodeImmutableFields,
            encodeMutableFields,
        )

        // Transfer Assets
        let loanaddress = contractIdToAddress!(newloan)

        transferToken!(loanee, loanaddress, collateral, amount) // Assets Transferred

        // Fee Collection
        transferToken!(loanee, selfAddress!(), alph, getFee())

        emit LoanCreated(loanee, newloan, collateral, amount, want, wamount, funds, nfunds)

        return newloan
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn pacaloan() -> () { // PACA Discount
        // Create Sub Contract
        let loanee = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = Loan.encodeFields!(want, wamount, collateral, amount, interest, time, loanee, time, interest, amount, loanee)

        let newloan = createContract!{loanee -> ALPH: 1 alph}(
            loan,
            encodeImmutableFields,
            encodeMutableFields,
        )

        // Transfer Assets
        let loanaddress = contractIdToAddress!(newloan)

        transferToken!(loanee, loanaddress, collateral, amount) // Assets Transferred

        // Fee Collection
        transferToken!(loanee, selfAddress!(), getNToken(), getNTokenFee())

        emit LoanCreated(loanee, newloan, collateral, amount, want, wamount, funds, nfunds)

        return newloan
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn createpool() -> () { // Dapp to User (Much Higher Collateral Required) USDT / ALPH + AYIN / ALPH
        let caller = callerAddress!()

        assert!(caller == owner, Error.InvalidCaller)

        let (encodeImmutableFields, encodeMutableFields) = Pool.encodeFields!(symbol, name, decimals, tokenTotal, minter)

        let newloan = createSubContract!
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn removealph() -> () { // Dapp to User (Much Higher Collateral Required) USDT / ALPH + AYIN / ALPH
        let caller = callerAddress!()

        assert!(caller == owner, Error.InvalidCaller)

        transferTokenFromSelf!(owner, alph, funds)

        emit Removed(owner, funds)
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn removepaca() -> () { // Dapp to User (Much Higher Collateral Required) USDT / ALPH + AYIN / ALPH
        let caller = callerAddress!()

        assert!(caller == owner, Error.InvalidCaller)

        transferTokenFromSelf!(owner, getNToken, nfunds)

        emit Removed(owner, nfunds)
    }

} 