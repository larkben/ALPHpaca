// This is the token swap offer for the token the user is willing to give up and the token the user wants to recieve

Contract Swapoffer (
    ByteVec: tokenOffered,
    ByteVec: tokenWanted,
    mut U256: offered,
    mut U256: wanted,
    Address: owner
) {

    event OfferCanceled(creator: Address, id: ByteVec)
    event OfferCompleted(creator: Address, user: Address, id: ByteVec) 

    enum ErrorCodes = {
        InvalidCaller = 1
        InvalidAssets = 2
    }

    pub fn getOfferedToken() -> ByteVec {
        return tokenOffered
    }

    pub fn getWantedToken() -> ByteVec {
        return tokenWanted
    }

    pub fn getOfferedAmt() -> U256 {
        return offered
    }

    pub fn getWantedAmt() -> U256 {
        return wanted
    }

    pub fn getSymbol() -> ByteVec {
        return tokenOffered
    }

    pub fn getName() -> ByteVec {
        return tokenOffered
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = false, checkExternalCaller = false)
    pub fn acceptswap() -> () {
        
        let caller = callerAddress!()

        transferToken!(caller, owner, getWantedToken(), getWantedAmt())                 // creator gets paid
        transferToken!(selfAddress!(), caller, getOfferedToken(), getOfferedAmt())      // user gets paid

        destroySelf!(owner)                                                             // gets their one alph deposit back

        emit OfferCompleted(owner, caller, selfContractId!())
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = false, checkExternalCaller = false)
    pub fn cancelswap() -> () {
        
        let minter = callerAddress!()

        checkCaller!(minter == owner, ErrorCodes.InvalidCaller)                         // only the caller can cancel the swap
        
        destroySelf!(owner)                                                             // gets their one alph deposit back

        emit OfferCanceled(owner, caller)
        
    }


}